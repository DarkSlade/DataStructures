Hamming numbers generator implementated in C.

===== Compile =====
`make`

===== Run =====
`./sequence_generation`

===== Testing =====
There are some simple tests that just make sure things are behaving as they're supposed to.
This tests the linked list implementation and the hamming numbers generator output.
Run valgrind to make sure there are no memory leaks
`make test`
`./test` 
`valgrind test`

===== Clean =====
`make clean`

===== Explanation for when seq can be printed safely =====
During the generation of the sequence, the nth number of the final sequence may not be the actual nth hamming number, there may be other numbers that have not been generated yet that could be less than the nth number of the final sequence, so we must continue generating terms until nth number of the final sequence is less than or equal to the smallest generated term in the temp list. At this point we know that no more terms can be generated smaller than the smallest term in the temp list making all numbers less than this smallest term correct in the final sequence.

===== Assignment =====
This exercise is to develop and implement the following algorithm and data structures that prints a list, in ascending order and with no duplicate, of positive integers that have no prime factor other than 2, 3, or 5. No credit will be given if your implementations do not follow the requirement.

This problem, proposed by R. Hamming, is to print a list, in ascending order and with no duplicate, of positive
integers that have no prime factor other than 2, 3, or 5. 
Thus the desired sequence is:
2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, . . .
Each term of this sequence is a positive integer of the form 2i 3j 5k , for all non-negative integers i, j, and k with
i + j + k ≥ 1.

Algorithm
An algorithm to solving this problem involves the repeated creation and merger of lists. The following lists are
maintained in the algorithm:
(a) A list Lfinal , empty to begin with, of all the terms of the desired sequence.
(b) A list Ltemp , initially 2, 3, 5, contains some, but not all, of the terms of the desired sequence that are
transferred to Lfinal .
(c) Three lists, L2−terms , L3−terms , and L5−terms , are generated by multiplying the current contents of Ltemp
by 2, 3, and 5, respectively.

In the algorithm, five lists: a final list, a temp list, and three term lists, evolve in the following manner. The final list grows by being merged with the current temp list. The temp list, in turn, is replaced by the merger of the three term lists. New term lists are generated by multiplying the new temp list by 2, 3, and 5 respectively.

Develop a program named Sequence Generation that:
(a) Prompts the user for the prefix-length n of the desired sequence (that is, the number of the first n (correct) terms in the desired sequence,
(b) Carries out all the list generation and merging (note that your program must provide a pointer/reference-
based implementation of linked lists for the list-manipulation), and
(c) Prints out the length-n prefix in the desired sequence.

Your documentation must include an explanation on how you know how much of the final list can be safely printed
at any point.

Declare appropriate data structures and subprograms that aid the list generation and merging.
Your main program encapsulating the implementations of the necessary packages/subprograms and testing code
should incorporate adequate documentation and good programming styles. (When in doubt, please ask.) Also,
subprograms should be properly documented with objectives, pre- and post-conditions.

Develop a simple plan for implementing, testing, and debugging your program. Use bottom-up testing to comple-
ment the top-down approach.



Double linked list implementation is provided.
Makefile file provided to easily build/clean application.


